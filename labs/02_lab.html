<h1 id="objectifs">Objectifs</h1>

<ul>
  <li>
    <p>Apprendre à effectuer des manipulations de bits spécifiques grâce à des compositions d’opérations sur les bits.</p>
  </li>
  <li>
    <p>Apprendre à identifier les problèmes potentiels en relation avec la gestion dynamique de la mémoire.</p>
  </li>
</ul>

<h1 id="exercice-1--bitops">Exercice 1 : (BitOps)</h1>

<p>Commencez d’abord par télécharger le fichier de démarrage (voir plus haut dans ce document) et décompressez son contenu dans le répertoire de votre choix. Implémentez ensuite dans le fichier <code class="language-plaintext highlighter-rouge">bit_ops.c</code> les fonctions de manipulation de bits<code class="language-plaintext highlighter-rouge"> get_bit()</code>, <code class="language-plaintext highlighter-rouge">set_bit()</code> et<code class="language-plaintext highlighter-rouge"> flip_bit()</code> (illustrées ci-dessous). Vous pouvez utiliser <strong>UNIQUEMENT</strong> des <a href="&quot;/l2cod/static_files/docs/bitwise_operations_in_c.html&quot;">opérations de manipulation de bits</a> comme le <strong>ET</strong> (<code class="language-plaintext highlighter-rouge">&amp;</code>), le <strong>OU</strong> (<code class="language-plaintext highlighter-rouge">|</code>), le <strong>XOR</strong> (<code class="language-plaintext highlighter-rouge">^</code>), le <strong>NOT</strong> (<code class="language-plaintext highlighter-rouge">~</code>), le <strong>décalage à gauche</strong> (<code class="language-plaintext highlighter-rouge">&lt;&lt;</code>) et le <strong>décalage à droite</strong> (<code class="language-plaintext highlighter-rouge">&gt;&gt;</code>). Vous ne pouvez pas utiliser de boucles <code class="language-plaintext highlighter-rouge">for</code> / <code class="language-plaintext highlighter-rouge">while</code> / <code class="language-plaintext highlighter-rouge">do</code> ou les instructions de condition <code class="language-plaintext highlighter-rouge">if / else</code> et <code class="language-plaintext highlighter-rouge">switch / case</code>. Vous ne pouvez pas non plus utiliser les opérations arithmétiques ( modulo (%), division, soustraction, addition ou multiplication ) pour cet exercice.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Retourne le n-ième bit de x.</span>
<span class="c1">// Vous pouvez considérer que 0 &lt;= n &lt;= 31</span>
<span class="n">bool</span> <span class="nf">get_bit</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">x</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">n</span><span class="p">);</span>

<span class="c1">// Fixe le n-ième bit de la valeur de x à v.</span>
<span class="c1">// Vous pouvez considérer que 0 &lt;= n &lt;= 31, et v est soit 0 ou 1</span>
<span class="kt">void</span> <span class="nf">set_bit</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">n</span><span class="p">,</span> <span class="n">bool</span> <span class="n">v</span><span class="p">);</span>

<span class="c1">// Inverse le n-ième bit de la valeur de x.</span>
<span class="c1">// Vous pouvez considérer que 0 &lt;= n &lt;= 31</span>
<span class="kt">void</span> <span class="nf">flip_bit</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">n</span><span class="p">);</span>
</code></pre></div></div>

<h2 id="tâches-à-réaliser-">Tâches à réaliser :</h2>

<p>Après avoir achevé l’implémentation des fonctions <code class="language-plaintext highlighter-rouge">get_bit()</code>, <code class="language-plaintext highlighter-rouge">set_bit()</code> et <code class="language-plaintext highlighter-rouge">flip_bit()</code>, vous pouvez compiler et exécuter le code fourni à l’aide des commandes ci-dessous (sous environnement UN*X). Une exécution corrècte du programme affichera sur votre écran le résultat de quelques tests de validation (tests qui vous permettent de vérifier si vous avez implémenté correctement les fonctions sus-citées).</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>make bit_ops
<span class="gp">$</span><span class="w"> </span>./bit_ops
</code></pre></div></div>

<h1 id="exercice-2--lfsr">Exercice 2 : (LFSR)</h1>

<p>Dans cet exercice, vous implémenterez une fonction <code class="language-plaintext highlighter-rouge">lfsr_calculate()</code> pour calculer la prochaine itération d’un registre à décalage à rétroaction linéaire <a href="https://fr.wikipedia.org/wiki/Registre_%C3%A0_d%C3%A9calage_%C3%A0_r%C3%A9troaction_lin%C3%A9aire">LFSR</a>. Les applications qui utilisent les LFSR sont: la télévision numérique, les téléphones portables CDMA, Ethernet, USB 3.0 et bien plus encore ! Dans <code class="language-plaintext highlighter-rouge">lfsr.c</code>, implémentez la fonction <code class="language-plaintext highlighter-rouge">lfsr_calculate()</code> pour qu’elle réalise l’opération illustrée ci-dessous :</p>

<p><img src="&quot;/l2cod/static_files/images/lfsr.gif&quot;" alt="LFSR" height="50%" width="50%" class="aligncenter" /></p>

<h2 id="explications-">Explications :</h2>
<ul>
  <li>
    <p>Si vous vous demandez à quoi sert cette fonction… elle est utilisée pour générer des nombres pseudo-aléatoires.</p>
  </li>
  <li>
    <p>A chaque appel à <code class="language-plaintext highlighter-rouge">lfsr_calculate()</code>, le contenu du registre est déplacé d’un bit vers la droite.</p>
  </li>
  <li>
    <p>Ce décalage n’est ni un décalage logique ni un <a href="https://fr.wikipedia.org/wiki/Op%C3%A9ration_bit_%C3%A0_bit#D%C3%A9calage_arithm%C3%A9tique">décalage arithmétique</a>. Sur le côté gauche, nous injectons un bit qui est égal au OU exclusif (XOR) des bits originaires des positions 0, 2, 3 et 5.</p>
  </li>
  <li>
    <p>Dans l’image ci-dessus, le symbole rouge illustrant un signe <code class="language-plaintext highlighter-rouge">plus dans un cercle</code> représente un <code class="language-plaintext highlighter-rouge">OU exclusif</code>. Rappelons que cet opérateur prend deux entrées <code class="language-plaintext highlighter-rouge">{a , b}</code> et réalise l’opération <code class="language-plaintext highlighter-rouge">a ^ b</code>.</p>
  </li>
  <li>
    <p>Si vous avez implémenté correctement <code class="language-plaintext highlighter-rouge">lfsr_calculate()</code>, la fonction devrait afficher tous les 65535 entiers positifs sur 16 bits avant de revenir au nombre initial de départ.</p>
  </li>
  <li>
    <p>Notez que le bit le plus à gauche est le MSB (bit de poids fort) et le bit le plus à droite est le LSB (bit de poids faible).</p>
  </li>
</ul>

<h2 id="tâches-à-réaliser--1">Tâches à réaliser :</h2>

<p>Implémentez la fonction <code class="language-plaintext highlighter-rouge">lfsr_calculate()</code> dans le fichier <code class="language-plaintext highlighter-rouge">lfsr.c</code> puis compilez et exécutez le programme (à l’aide de la commande <code class="language-plaintext highlighter-rouge">make</code> sous UN*X - voir ci-dessous). Vérifiez que le résultat affiché sur votre écran ressemble à ce qui suit :</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>make lfsr
<span class="gp">$</span><span class="w"> </span>./lfsr
<span class="go">My number is: 1
My number is: 5185
My number is: 38801
My number is: 52819
My number is: 21116
My number is: 54726
My number is: 26552
My number is: 46916
My number is: 41728
My number is: 26004
My number is: 62850
My number is: 40625
My number is: 647
My number is: 12837
My number is: 7043
My number is: 26003
My number is: 35845
My number is: 61398
My number is: 42863
My number is: 57133
My number is: 59156
My number is: 13312
My number is: 16285
 ... etc etc ...
Got 65535 numbers before cycling!
Congratulations! It works!
</span></code></pre></div></div>

<h1 id="exercise-3--accès-mémoire">Exercise 3 : (Accès mémoire)</h1>

<p>Cet exercice est conçu pour vous aider à vous familiariser avec les structures de données et la manipulation des pointeurs (c-à-d. adresses mémoires) dans le langage C. Les fichiers <code class="language-plaintext highlighter-rouge">vector.h</code>, <code class="language-plaintext highlighter-rouge">vector-test.c</code> et <code class="language-plaintext highlighter-rouge">vector.c</code> implémentent des fonctionnalités pour gérer des tableaux de longueur variable.</p>

<h2 id="tâches-à-réaliser--2">Tâches à réaliser :</h2>

<ul>
  <li>
    <p>Expliquez pourquoi <code class="language-plaintext highlighter-rouge">bad_vector_new()</code> et <code class="language-plaintext highlighter-rouge">also_bad_vector_new()</code> sont de mauvaises implémentations et complétez les fonctions <code class="language-plaintext highlighter-rouge">vector_new()</code>, <code class="language-plaintext highlighter-rouge">vector_get()</code>, <code class="language-plaintext highlighter-rouge">vector_delete()</code> et <code class="language-plaintext highlighter-rouge">vector_set()</code> dans <code class="language-plaintext highlighter-rouge">vector.c</code>.</p>
  </li>
  <li>
    <p>Insérez également les prototypes de ces fonctions dans le fichier entête <code class="language-plaintext highlighter-rouge">vector.h</code> afin que le code de test <code class="language-plaintext highlighter-rouge">vector-test.c</code> puisse s’exécuter sans aucune erreur.</p>
  </li>
  <li>
    <p>Enfin, implémentez une règle pour la cible <code class="language-plaintext highlighter-rouge">vector-test</code> dans le fichier « Makefile ».</p>
  </li>
</ul>

<p>Consultez les fonctions déjà implémentées et les commentaires fournis pour voir comment les structures de données doivent être manipulées.</p>

<p>Par souci de cohérence, il est supposé que toutes les entrées du vecteur sont égales à <code class="language-plaintext highlighter-rouge">0</code> à moins qu’elles ne soient explicitement définies ou modifiées par l’utilisateur. Rappelez-vous de cela parce que la fonction <code class="language-plaintext highlighter-rouge">malloc()</code> ne met pas à zéro la mémoire qu’elle alloue.</p>

<p>Pour expliquer pourquoi les deux mauvaises fonctions sont incorrectes, gardez à l’esprit que l’une de ces fonctions s’exécutera correctement mais il peut y avoir d’autres problèmes (invisibles).</p>

<p>Vérifiez votre implémentation de <code class="language-plaintext highlighter-rouge">vector_new()</code>, <code class="language-plaintext highlighter-rouge">vector_get()</code>, <code class="language-plaintext highlighter-rouge">vector_delete()</code> et <code class="language-plaintext highlighter-rouge">vector_set()</code> par rapport à l’exactitude des résultats et aussi par rapport à la gestion corrècte de la mémoire (détails ci-dessous).</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">#</span><span class="w"> </span>1<span class="o">)</span> pour vérifier l<span class="s1">'exactitude des résultats
</span><span class="gp">$</span><span class="w"> </span><span class="s1">make vector-test
</span><span class="gp">$</span><span class="w"> </span><span class="s1">./vector-test
</span><span class="go">
</span><span class="gp">#</span><span class="w"> </span>2<span class="o">)</span> pour vérifier la gestion de la mémoire avec Valgrind
<span class="gp">$</span><span class="w"> </span>make vector-memcheck
</code></pre></div></div>

<p>La <a href="https://www.gnu.org/software/make/manual/make.html#Rule-Introduction">règle</a> <code class="language-plaintext highlighter-rouge">vector-memcheck</code> dans le fichier ‘Makefile’ permet d’exécuter la commande suivante de <code class="language-plaintext highlighter-rouge">valgrind</code> sur un fichier <code class="language-plaintext highlighter-rouge">executable</code>.</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>valgrind <span class="nt">--tool</span><span class="o">=</span>memcheck <span class="nt">--leak-check</span><span class="o">=</span>full <span class="nt">--track-origins</span><span class="o">=</span><span class="nb">yes</span> <span class="o">[</span>OS SPECIFIC ARGS] ./&lt;executable&gt;
</code></pre></div></div>

<p>Que signifie chacun des paramètres dans la commande précédente (<strong>Indication :</strong> Comment obtenir de l’aide sur une instruction sous UN*X) ? La dernière ligne affichée par <code class="language-plaintext highlighter-rouge">valgrind</code> vous indiquera en un coup d’œil s’il y a eu des erreurs pendant l’exécution de votre programme. Voici un exemple de sortie d’un programme bogué :</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="go">==47132== ERROR SUMMARY: 1200039 errors from 24 contexts (suppressed: 18 from 18)
</span></code></pre></div></div>

<p>Si votre programme comporte des erreurs, vous pouvez faire défiler la sortie de la ligne de commande pour afficher les détails de chacune des erreurs. Pour cet exercice, vous pouvez ignorer toutes les sorties faisant référence à des erreurs supprimées (<em>anglais</em> : suppressed). Dans un programme sans problèmes de mémoire, votre sortie ressemblera à ceci :</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="go">==44144== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 18 from 18)
</span></code></pre></div></div>

<p>Au final, n’hésitez pas à utiliser également CGDB ou à ajouter des instructions <code class="language-plaintext highlighter-rouge">printf</code> à <code class="language-plaintext highlighter-rouge">vector.c</code> et <code class="language-plaintext highlighter-rouge">vector-test.c</code> pour déboguer votre code.</p>
