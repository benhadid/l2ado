<h1 id="objectifs">Objectifs</h1>

<ul>
  <li>
    <p>Comprendre la gestion des exceptions et interruptions dans MIPS</p>
  </li>
  <li>
    <p>Apprendre à écrire des gestionnaires d’exception dans MIPS.</p>
  </li>
</ul>

<h1 id="exercice-1--types-dexceptions">Exercice 1 : (Types d’exceptions)</h1>

<p>Lancez l’exemple de code suivant dans MARS, puis répondez aux questions ci-dessous.</p>

<pre><code class="language-assembly">   .text
   .globl main  
main:
  li $t0, 2147483647   #
  li $t1, 5000
  add $a0, $t0, $t1    #

  li $v0, 10           # exit
  syscall
</code></pre>

<ol>
  <li>
    <p>Quelle est la valeur (en hexadécimal) du registre <strong>status</strong> du coprocesseur 0 ?</p>
  </li>
  <li>
    <p>Quelle est la valeur (en hexadécimal) du registre <strong>cause</strong> du coprocesseur 0 ?</p>
  </li>
  <li>
    <p>Quel type d’exception s’est produite ?</p>
  </li>
  <li>
    <p>A quelle adresse (en hexadécimal) s’est produite l’exception ?</p>
  </li>
</ol>

<h1 id="exercice-2--interruptions">Exercice 2 : (Interruptions)</h1>

<p>L’activation des interruptions sur un processeur MIPS se fait en deux étapes :</p>

<ul>
  <li>
    <p><strong>Configurer le périphérique en question pour qu’il envoie des signaux d’interruption</strong>
Cela requiert en général l’activation d’un bit de validation d’interruption dans un registre de contrôle dans le périphérique.</p>
  </li>
  <li>
    <p><strong>Configurer le coprocesseur 0 pour accépter les signaux d’interruption</strong>
Ceci est effectué en mettant à 1 le bit 0 du registre status ($12) pour activer les interruptions d’une manière globale, puis, en définissant des bits particuliers dans le registre status, on activera des interruptions spécifiques. En effet, les bits 8 à 15 du registre status permettent 8 niveaux d’interruption différents. Par exemple, les bits 3 et 4 du masque (11 et 12 du registre status) activent les interruptions clavier (keyboard) et affichage (display), respectivement.</p>
  </li>
</ul>

<p>Si nous voulions activer <strong>toutes</strong> les interruptions dans le MIPS, complétez le masque de bits pour l’instruction <code class="language-plaintext highlighter-rouge">ori</code> :</p>

<pre><code class="language-assembly">   mfc0    $s1, $12         # lire le contenu du registre status et l'affecter à $s1
   ori     $s1, _________   # à compléter
   mtc0    $s1, $12         # mise à jour du contenu du registre status à partir de $s1
</code></pre>

<p>Si nous voulions activer <strong>que</strong> les interruptions pour le clavier et l’affichage, complétez le masque de bits pour l’instruction <code class="language-plaintext highlighter-rouge">ori</code> :</p>

<pre><code class="language-assembly">   mfc0    $s1, $12         # lire le contenu du registre status et l'affecter à $s1
   ori     $s1, _________   # à compléter
   mtc0    $s1, $12         # mise à jour du contenu du registre status à partir de $s1
</code></pre>

<h1 id="exercice-3--gestion-des-exceptions">Exercice 3 : (Gestion des exceptions)</h1>

<p>Un gestionnaire d’exceptions doit signaler l’adresse de l’instruction qui a provoqué l’exception, le code d’exception, et doit reprendre (ou terminer) l’exécution du programme après avoir traité l’exception.</p>

<ol>
  <li>
    <p>Pour cet exercice, nous allons utiliser un gestionnaire d’exceptions personnalisé au lieu de celui qui est déjà intégré dans MARS. Pour installer notre gestionnaire d’exceptions, veuillez suivre les instructions suivantes :</p>

    <ol>
      <li>
        <p>Commencez par télécharger le fichier de démarrage (voir plus haut dans ce document). Le fichier obtenu (<code class="language-plaintext highlighter-rouge">exceptions_handler.s</code>) est gestionnaire d’exceptions MIPS personnalisé.</p>
      </li>
      <li>
        <p>Dans MARS, accédez à “<strong>Settings</strong>” dans les menus déroulants.<br />
<img src="/static_files/images/mars_exception_handler.png" alt="Mars exception handler" /></p>
      </li>
      <li>
        <p>Cochez la case “Initialize Program Counter to global ‘main’ if defined”</p>
      </li>
      <li>
        <p>Refaite l’étape <strong>(ii)</strong> et cliquez sur l’élément “<strong>Exception Handler</strong>”. Une nouvelle boîte de dialogue apparaîtra.
<img src="/static_files/images/mars_ehandler2.png" alt="Mars exception handler 2" /></p>
      </li>
      <li>
        <p>Cochez la case “<strong>Include this exception handler file in all assemble operations</strong>”, puis entrez le chemin du fichier de gestionnaire d’exceptions que vous avez téléchargé. Choisissez OK pour terminer.</p>
      </li>
      <li>
        <p>MARS est désormais configuré pour utiliser notre nouveau gestionnaire d’exceptions au lieu du gestionnaire intégré.</p>
      </li>
    </ol>
  </li>
  <li>
    <p>Dans l’éditeur de MARS, écrivez un programme complet pour tester des instructions qui provoquent : un débordement, des accès à des adresses de mémoire non valides, des instructions de déroutement (trap) et des instructions de breakpoint. Votre programme <strong>doit</strong> commencer par ce bout de code :</p>

    <pre><code class="language-assembly">.globl
main:
</code></pre>
  </li>
  <li>
    <p>Modifiez le gestionnaire d’exceptions pour afficher le <strong>vaddr</strong> non valide quand l’exception est provoquée par un chargement (load), un stockage (store) ou une lecture d’instruction (code d’exception 4 ou 5). Testez votre gestionnaire d’exceptions en écrivant des instructions de chargement et de stockage générant des adresses mémoire non valides.</p>
  </li>
  <li>
    <p>A l’aide des E/S mappée en mémoire et le polling (consultez le document « Mécanismes d’exceptions dans MIPS » disponible à partir du site du <a href="/lectures/">cours</a>), écrire une fonction <code class="language-plaintext highlighter-rouge">print_string</code> qui imprime une chaîne sur l’écran, sans utiliser aucun appel système (c.-à-d. sans <code class="language-plaintext highlighter-rouge">syscall</code>). L’adresse de la chaîne est passée dans le registre <code class="language-plaintext highlighter-rouge">$a0</code> et la chaîne doit être terminée par le caractère NUL (zéro). Testez cette fonction en l’appelant à partir de la fonction principale. Assurez-vous d’activer le simulateur de clavier et d’affichage MMIO à partir du menu (<strong>Tools | Keyboard and Display MMIO Simulator</strong>) et de connecter ce simulateur à MARS en cliquant sur le bouton « <strong>Connect to MIPS</strong> ».</p>
  </li>
  <li>
    <p>Toujours à l’aide des E/S mappée en mémoire et le polling,  écrire un programme qui lit les caractères directement à partir du clavier (consultez le document « Mécanismes d’exceptions dans MIPS »). Pour montrer la lenteur du clavier, imprimer le caractère saisi et le nombre d’itérations après la sortie de la boucle <code class="language-plaintext highlighter-rouge">wait_keyboard</code> (voir le document « Mécanismes d’exceptions dans MIPS »). Répéter l’exécution du programme jusqu’à ce que vous appuyiez sur la touche retour du clavier. Assurez-vous d’exécuter le simulateur MARS à la vitesse maximale.</p>
  </li>
  <li>
    <p>Si le bit d’activation d’interruption du clavier est activé, le clavier interrompra le processeur à chaque pression sur une touche. Écrire un <strong>gestionnaire d’interruption</strong> simple qui renvoie le caractère saisi dans le registre <code class="language-plaintext highlighter-rouge">$v0</code>. Réécrire la fonction principale de la question n°4 en utilisant les interruptions du clavier.</p>
  </li>
  <li>
    <p>A l’aide des E/S mappée en mémoire et le polling, écrire une fonction <code class="language-plaintext highlighter-rouge">read_string</code> qui lit une chaîne de caractères directement à partir du clavier. La fonction récupérera les caractères du clavier et les stocke dans un tableau pointé par le registre <code class="language-plaintext highlighter-rouge">$a0</code>. La fonction doit continuer jusqu’à ce que <code class="language-plaintext highlighter-rouge">n-1</code> caractères soient lus ou que le caractère de nouvelle ligne soit reçu (c.-à-d. touche retour enfoncée). Le paramètre <code class="language-plaintext highlighter-rouge">n</code> doit être passé dans le registre <code class="language-plaintext highlighter-rouge">$a1</code>. La fonction doit insérer un octet <code class="language-plaintext highlighter-rouge">NUL</code> à la fin de la chaîne et devrait renvoyer le nombre réel de caractères lus dans le registre <code class="language-plaintext highlighter-rouge">$v0</code>. Assurez-vous d’activer le Simulateur de clavier et d’affichage MMIO et de connecter le simulateur à Mars. Écrivez une fonction principale pour tester plusieurs fois <code class="language-plaintext highlighter-rouge">read_string</code> et pour afficher la chaîne de caractère après chaque appel.</p>
  </li>
</ol>
