<h1 id="objectifs">Objectifs</h1>

<ul>
  <li>
    <p>Maîtrise des conventions d’appel de fonctions dans MIPS</p>
  </li>
  <li>
    <p>Maîtriser l’assemblage de plusieurs fichiers d’un projet MIPS avec MARS</p>
  </li>
</ul>

<h1 id="préambule">Préambule</h1>

<p>Commencez par télécharger le fichier de démarrage et décompressez son contenu dans le répertoire de votre choix. Après avoir codé les fonctions des exercices ci-dessous, vous pouvez vérifier l’exactitude de vos implémentations en lançant les commandes suivantes sous environnement UN*X. (c.f. Le <a href="/labs/04_lab.html">TP précédent</a>) :</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span><span class="nb">cd </span>chemin/vers/le/repertoire/lab5
<span class="gp">$</span><span class="w"> </span><span class="nb">chmod</span> +x run_test.sh     <span class="c"># &lt;-- à faire la première fois seulement</span>
<span class="gp">$</span><span class="w"> </span>./run_tests.sh           <span class="c"># &lt;-- exécutez cela chaque fois que vous voulez tester vos codes </span>
</code></pre></div></div>
<h1 id="exercice-1--n_choose_k">Exercice 1 : (n_choose_k)</h1>

<p>Afin de respecter les conventions d’appel de fonctions dans MIPS, ajoutez dans le code <code class="language-plaintext highlighter-rouge">nchoosek/impl.s</code> aux endroits indiqués par le marqueur <code class="language-plaintext highlighter-rouge">### VOTRE CODE ICI ###</code> le prologue et l’épilogue de la fonction <code class="language-plaintext highlighter-rouge">nchoosek()</code> afin qu’elle calcule <em>le nombre de combinaisons de n éléments distincts choisis k fois</em>. Ceci peut être calculé à l’aide de factorielles, mais nous le ferons en recherchant l’entrée (n, k) dans le <a href="https://fr.wikipedia.org/wiki/Triangle_de_Pascal">triangle de Pascal</a>.</p>

<h1 id="exercice-2--polynôme">Exercice 2 : (polynôme)</h1>

<p>Une translation de code en C vers l’assembleur MIPS est donnée ci-dessous. Ici, le programme principal appelle la fonction <code class="language-plaintext highlighter-rouge">poly()</code> d’une manière répétitive pour les valeurs de <code class="language-plaintext highlighter-rouge">i</code> allant de 2 à 4. L’argument de la fonction <code class="language-plaintext highlighter-rouge">poly()</code> est passé dans le registre <code class="language-plaintext highlighter-rouge">$a0</code>.</p>

<pre><code class="language-assembly">#
# Description:  Calcule du polynôme x^4 + x^3 + 1, pour x allant de 2 à 4

# i  &lt;-&gt;  $s0

    .text

main:   addi    $s1, $0, 4      # main(){
        addi    $s0, $0, 2      #
m_for:  add     $a0, $s0, $0    #   for (i=2; i&lt;=4; i++) {
        jal     poly            #      result = poly(i);
                                #
        add     $a0, $v0, $0    #      printf("%d\n", result );
        addi    $v0, $0, 1      #        .
        syscall                 #        .
        addi    $a0, $0, '\n'   #        .
        addi    $v0, $0, 11     #        .
        syscall                 #        .
                                #
        addi    $s0, $s0, 1     #      i++;
        ble     $s0, $s1, m_for #  }
                                #
        addi    $v0, $0, 10     #     exit
        syscall                 #}      .
</code></pre>

<p>Écrivez dans <code class="language-plaintext highlighter-rouge">poly/impl.s</code> le corps de la fonction <code class="language-plaintext highlighter-rouge">poly(int x)</code> qui calcule le polynôme \(x^4 + x^3 + 1\) en respectant les conventions d’appel des fonctions dans MIPS.</p>

<p><strong>Indication</strong> : Pensez à définir une fonction <code class="language-plaintext highlighter-rouge">pow(x, n)</code> qui sera appelée par la fonction <code class="language-plaintext highlighter-rouge">poly()</code> et qui calcule \(x^n\).</p>

<h1 id="exercice-3--liste-chaînée">Exercice 3 : (liste chaînée)</h1>

<p>Soit une liste chaînée décrite avec la structure de donnée ci-dessous</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">node</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">value</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<p>Dans cet exercice, vous allez compléter l’implémentation de la fonction <code class="language-plaintext highlighter-rouge">map()</code> dans <code class="language-plaintext highlighter-rouge">map/impl.s</code> qui modifie les champs <code class="language-plaintext highlighter-rouge">value</code> de la liste chaînée. Les modifications se feront sur place (au lieu de créer et renvoyer une nouvelle liste avec les valeurs modifiées).</p>

<p>La fonction <code class="language-plaintext highlighter-rouge">map()</code> prend deux paramètres; le pointeur tête-de-liste (<em>c.-à-d.</em> l’adresse du premier nœud la liste); et un <em>pointeur de fonction</em> qui prend un <code class="language-plaintext highlighter-rouge">int</code> en argument et renvoie un <code class="language-plaintext highlighter-rouge">int</code> en sortie. La fonction <code class="language-plaintext highlighter-rouge">map()</code> parcourt de manière récursive la liste et applique la fonction donnée en paramètre au champ <code class="language-plaintext highlighter-rouge">value</code> de chaque nœud de la liste. Une implémentation en C de la fonction <code class="language-plaintext highlighter-rouge">map()</code> serait comme suit :</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">map</span> <span class="p">(</span><span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">f</span><span class="p">)</span> <span class="p">(</span><span class="kt">int</span><span class="p">))</span>
<span class="p">{</span>
  <span class="k">if</span><span class="p">(</span><span class="n">head</span><span class="o">==</span><span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span><span class="p">;</span> <span class="p">}</span>
  <span class="n">head</span><span class="o">-&gt;</span><span class="n">value</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">);</span>
  <span class="n">map</span><span class="p">(</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">,</span> <span class="n">f</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>La déclaration <code class="language-plaintext highlighter-rouge">int (*f)(int)</code> signifie simplement que <code class="language-plaintext highlighter-rouge">f</code> est un <em>pointeur de fonction</em> qui, en langage C, est utilisé exactement comme toute autre fonction (si vous êtes curieux, consultez ce <a href="https://www.geeksforgeeks.org/function-pointer-in-c/">lien</a> pour apprendre davantage sur leur utilisation).</p>

<p>Pour votre implémentation en assembleur MIPS de la fonction <code class="language-plaintext highlighter-rouge">map()</code>, vous aurez besoin d’utiliser l’instruction <code class="language-plaintext highlighter-rouge">jalr</code>. Cette instruction permet de sauter à l’adresse contenue dans le registre donné en paramètre et de stocker l’adresse de retour (c.-à-d. l’adresse de l’instruction après <code class="language-plaintext highlighter-rouge">jalr</code>) dans le registre <code class="language-plaintext highlighter-rouge">$ra</code>.</p>

<p>En fait, l’instruction <code class="language-plaintext highlighter-rouge">jalr</code> est à <code class="language-plaintext highlighter-rouge">jr</code> ce que <code class="language-plaintext highlighter-rouge">jal</code> est à <code class="language-plaintext highlighter-rouge">j</code>. Par exemple, pour appeler une fonction, nous pourrions utiliser l’instruction <code class="language-plaintext highlighter-rouge">jalr</code> au lieu de l’instruction <code class="language-plaintext highlighter-rouge">jal</code> comme illustré ci-dessous :</p>

<pre><code class="language-assembly"># Nous aimerions appeler la fonction `garply`, sans utiliser l'instruction `jal`.
la $t0, garply 	# nous utilisons la pseudo-instruction `la` pour charger l'adresse de `garply` dans un registre (ici $t0)
jalr $t0       	# puis, nous utilisons l'instruction `jalr` pour l'appel de fonction.
</code></pre>

<p>Le fichier <code class="language-plaintext highlighter-rouge">map/impl.s</code> contient 12 emplacements où il est indiqué <code class="language-plaintext highlighter-rouge">### VOTRE CODE ICI ###</code>. Insérez à ces endroits du code des <strong>instructions MIPS qui correspondent aux indications données dans les commentaires adjacents</strong> pour terminer l’implémentation de la fonction <code class="language-plaintext highlighter-rouge">map()</code>.</p>

<p>Une fois le code complété, l’exécution du programme dans MARS devrait donner un résultat similaire à celui-ci :</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="go">Liste Avant : 9 8 7 6 5 4 3 2 1 0
Liste Après : 81 64 49 36 25 16 9 4 1 0
</span></code></pre></div></div>

<h2 id="remarque-">Remarque :</h2>
<p>Pour exécuter ou tester votre code dans MARS,</p>
<ul>
  <li>chargez le fichier associé <code class="language-plaintext highlighter-rouge">map/impl_runner.s</code> dans MARS et cochez l’option <strong>Settings | Assemble all files in directory</strong> dans le menu,</li>
  <li>commenter dans le code la ligne indiquée par le marqueur <code class="language-plaintext highlighter-rouge"># &lt;&lt;&lt; Commenter sous MARS</code></li>
</ul>

<h1 id="exercise-4--liste-chaînée-bis">Exercise 4 : (liste chaînée-bis)</h1>

<p>Dans l’exercice précédent, vous avez complété une procédure MIPS qui appliquait une fonction à chaque nœud dans une liste chaînée. Ici, vous travaillerez avec une version similaire mais légèrement plus complexe. En effet, au lieu d’avoir une liste chaînée de « <code class="language-plaintext highlighter-rouge">int</code> », notre structure de données est une liste chaînée de tableaux de « <code class="language-plaintext highlighter-rouge">int</code> ». Pour rappel, lorsque nous traitons un tableau dynamique en C, nous devons stocker explicitement sa taille dans une variable. Voici, en langage C, à quoi ressemble la structure de notre liste chaînée :</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">node</span> <span class="p">{</span>
    <span class="kt">int</span><span class="o">*</span> <span class="n">arr</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">size</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">node</span><span class="o">*</span> <span class="n">next</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<p>Voici également une implémentation en C qui montre ce que fait la nouvelle fonction <code class="language-plaintext highlighter-rouge">map</code> : Dans chaque nœud de la liste chaînée, nous parcourons chaque élément du tableau dynamique et lui appliquons une fonction donnée. Le résultat de la fonction est stocké dans le tableau en écrasant l’ancienne valeur.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">map</span><span class="p">(</span><span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">f</span><span class="p">)(</span><span class="kt">int</span><span class="p">))</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">head</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">head</span><span class="o">-&gt;</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="p">}</span>
    <span class="n">map</span><span class="p">(</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">,</span> <span class="n">f</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="tâches-à-effectuer">Tâches à effectuer</h2>

<p>Trouvez et corrigez les erreurs dans <code class="language-plaintext highlighter-rouge">map2d/impl.s</code>. En ce sens, aidez-vous des lignes commentées dans le fichier source et <strong>assurez-vous que les instructions MIPS correspondent aux indications données dans les commentaires</strong>. Voici quelques indications :</p>

<ul>
  <li>Pourquoi avons-nous besoin de sauvegarder des informations dans la pile avant d’exécuter l’instruction <code class="language-plaintext highlighter-rouge">jal</code> ?</li>
  <li>Quelle est la différence entre « <code class="language-plaintext highlighter-rouge">add $t0, $s0, $0</code> » et « <code class="language-plaintext highlighter-rouge">lw $t0, 0($s0)</code> » ?</li>
  <li>Faites attention aux types des attributs dans la structure <code class="language-plaintext highlighter-rouge">struct node</code>.</li>
</ul>

<p>Pour référence, l’exécution du programme dans MARS devrait donner le résultat suivant :</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="go">Listes avant :
5 2 7 8 1
1 6 3 8 4
5 2 7 4 3
1 2 3 4 7
5 6 7 8 9

Listes après :
30 6 56 72 2
2 42 12 72 20
30 6 56 20 12
2 6 12 20 56
30 42 56 72 90
</span></code></pre></div></div>

<h2 id="remarque--1">Remarque :</h2>
<p>Pour exécuter ou tester votre code dans MARS,</p>
<ul>
  <li>chargez le fichier associé <code class="language-plaintext highlighter-rouge">map2d/impl_runner.s</code> dans MARS et cochez l’option <strong>Settings | Assemble all files in directory</strong> dans le menu,</li>
  <li>commenter dans le code la ligne indiquée par le marqueur <code class="language-plaintext highlighter-rouge"># &lt;&lt;&lt; Commenter sous MARS</code></li>
</ul>
