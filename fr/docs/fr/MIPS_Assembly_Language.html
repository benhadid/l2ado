<!DOCTYPE html>
<html>

  <head>
  
    <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-5KMKZK4Z38"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-5KMKZK4Z38');
  </script>
  

  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title> Le langage Assembleur MIPS - Architecture des ordinateurs / Automne 2024 </title>
  <meta name="description" content="IntroductionUn modèle de programme en langage Assembleur MIPS est illustré ci-dessous# Titre :# Auteur :# Date :# Description :# Paramètres en entrée :# Donn...">
  
  <!--for gitlab pages -->
  

  <!-- automatic favicons -->
  

    <!--for github pages -->
  <link rel="shortcut icon" href="https://benhadid.github.io/l2ado/favicon.ico?"> 
  <!--for github-->

  <link rel="stylesheet" href="/l2ado/fr/_css/main.css">
  <link rel="canonical" href="https://benhadid.github.io/l2ado/fr/docs/fr/MIPS_Assembly_Language">
  <link rel="alternate" type="application/rss+xml" title="Architecture des ordinateurs / Automne 2024 - " href="https://benhadid.github.io/l2ado/fr/feed.xml" />

  <link rel='stylesheet' id='open-sans-css'  href='//fonts.googleapis.com/css?family=Open+Sans%3A300italic%2C400italic%2C600italic%2C300%2C400%2C600&#038;subset=latin%2Clatin-ext&#038;ver=4.2.4' type='text/css' media='all' />
  <link href='https://fonts.googleapis.com/css?family=Titillium+Web:600italic,600,400,400italic' rel='stylesheet' type='text/css'>

  

  

  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.2.0/css/all.css" integrity="sha384-hWVjflwFxL6sNzntih27bfxkr27PmbbK/iSvJ+a4+0owXq79v+lsFkW54bOGbiDQ" crossorigin="anonymous">

  <!-- MathJax -->
  <script type="text/javascript" async
    src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML">
  </script>
</head>


  <body>

    <header class="site-header">

  <div class="wrapper" style="z-index: 100;">
      <table><tr>
          <td><img width="75" src="/l2ado/_images/logo.png" valign="middle"></td>
          <td style="padding-left:10px;"><a class="schoolname" style="font-size: 15px;" class="site-title" href=""></a>
          <br/>      
          <span style="margin-top: -2px;margin-bottom: -10px;" class="site-title"><a href="/l2ado/fr/" title="Architecture des ordinateurs / Automne 2024 - "><b>Architecture des ordinateurs</a></b></span>
          <br/>
          <span class="coursesemeter" style="font-size: 12px;font-weight: bold;margin-top: 10px;display: block;">Automne 2024</span>
          </td>
        </tr></table>

    <nav class="site-nav">

      <a href="#" class="menu-icon menu.open">
        <svg viewBox="0 0 18 15">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </a>  

    <div class="trigger"><h1>Main Navigation</h1> <ul class="menu">
    
    <li>

      
      

      <a class="page-link" href="/l2ado/fr/">
        <i class="fa fa-home fa-lg"></i> Accueil
      </a>

    </li>
    
    <li>

      
      

      <a class="page-link" href="/l2ado/fr/schedule/">
        <i class="fas fa-calendar-alt"></i> Calendrier
      </a>

    </li>
    
    <li>

      
      

      <a class="page-link" href="/l2ado/fr/lectures/">
        <i class="fas fa-book-reader"></i> Cours
      </a>

    </li>
    
    <li>

      
      

      <a class="page-link" href="/l2ado/fr/discussions/">
        <i class="fas fa-user-graduate"></i> T. Dirigés
      </a>

    </li>
    
    <li>

      
      

      <a class="page-link" href="/l2ado/fr/labs/">
        <i class="fas fa-laptop-code"></i> T. Pratiques
      </a>

    </li>
    
    <li>

      
      

      <a class="page-link" href="/l2ado/fr/quizzes/">
        <i class="fas fa-question-circle"></i> Quiz
      </a>

    </li>
    
    <li>

      
      

      <a class="page-link" href="/l2ado/fr/projects/">
        <i class="fas fa-user-graduate"></i> Projets
      </a>

    </li>
    
    <li>

      
      

      <a class="page-link" href="/l2ado/fr/materials/">
        <i class="fas fa-book"></i> Ressources
      </a>

    </li>
    
</ul>
 </div>  
    
    </nav>
  </div>

  <div></div>

  <div class="header-texture" style="height:100%; z-index: 0; position: absolute; top:0; right: 0; left: 0; background-image: url( /l2ado/_images/pattern.png );" >
  </div>

</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="post">

  <header class="post-header">
    <h1 class="post-title">Le langage Assembleur MIPS</h1>
  </header>

  <article class="post-content">
    <h1 id="introduction">Introduction</h1>

<p>Un modèle de programme en langage Assembleur MIPS est illustré ci-dessous</p>

<pre><code class="language-mips"># Titre :
# Auteur :
# Date :
# Description :
# Paramètres en entrée :
# Données retournées :
################### segment de données ###################### 
.data
. . .
###################  segment de code  #######################
.text
.globl main 
main:                     # début de la fonction main
. . .
li $v0, 10 
syscall                   # appel système pour quitter

</code></pre>

<p>Il existe trois types d’instructions qui peuvent être utilisées dans le langage assembleur, où chaque instruction apparaît sur une ligne distincte :</p>

<ol>
  <li>
    <p><em>Directives de l’assembleur</em> : Celles-ci fournissent des informations à l’<em>outil Assembleur</em> pour la traduction d’un programme en code machine. Les directives sont utilisées pour définir des segments et allouer de l’espace dans la mémoire pour les variables globales du programme. Une directive de l’assembleur commence toujours par un point (.). Un programme typique en langage assembleur MIPS utilise les directives suivantes :
  <strong>.data</strong>   définit le segment de données du programme, contenant les variables globales du programme.<br />
  <strong>.text</strong>   définit le segment de code du programme, contenant les instructions à exécuter.
  <strong>.globl</strong>  définit un symbole (étiquette) comme global qui peut être référencé à partir d’autres  fichiers.</p>
  </li>
  <li>
    <p><em>Instructions exécutables</em> : Celles-ci génèrent du code machine qui sera exécuté par le processeur. Les instructions indiquent au processeur ce qu’il faut faire.</p>
  </li>
  <li>
    <p><em>Pseudo-Instructions et macros</em> : Traduit par l’<em>outil Assembleur</em> en instructions réelles. Ces pseudo-instructions simplifient la tâche du programmeur.</p>
  </li>
</ol>

<p>En outre, des commentaires peuvent être insérés dans le code. Les commentaires sont très importants pour les programmeurs, mais ignorés par l’<em>outil Assembleur</em>. Dans MIPS, un commentaire commence par le symbole <code class="language-plaintext highlighter-rouge">#</code> et se termine à la fin de la ligne. Les commentaires peuvent apparaître au début d’une ligne ou après une instruction. Ils expliquent l’objet du programme, quand il a été écrit, révisé, et par qui. Ils expliquent les données et les registres utilisés dans le programme, les entrées, les sorties, la séquence d’instructions et les algorithmes implémentés.</p>

<h1 id="le-cycle-edition-assemblage-liaison-exécution">Le Cycle Edition-Assemblage-Liaison-Exécution</h1>

<p>Avant de pouvoir exécuter un programme MIPS, nous devons convertir le texte source écrit en langage assembleur en une forme exécutable par le processeur. Cela est effectué en deux étapes :</p>

<ol>
  <li>
    <p><em>Assembler</em> :  Traduit le texte en langage assembleur vers un fichier objet binaire. Cela est réalisé par l’<em>outil Assembleur</em>. S’il y’a plus d’un fichier source en langage assembleur, alors chacun de ces fichiers sera assemblé séparément.</p>
  </li>
  <li>
    <p><em>Edition de Liens</em> : Combine tous les fichiers objets ensemble (s’il y’en a plus d’un) et éventuellement avec des bibliothèques de fonctions. Cela est réalisé par l’<em>éditeur de liens</em> (<em>anglais</em> : linker). Le linker vérifie et lie les appels de fonctions dans les fichiers objets avec des bibliothèques ou d’autres fichiers objets. Le résultat de cette étape produit un fichier exécutable.</p>
  </li>
</ol>

<p><img src="/l2ado/static_files/images/Edit-Assemble-Link-Execute_fr.png" alt="EALE" class="aligncenter" /></p>

<p>La figure ci-dessus résume le cycle <em>Edition-Assemblage-Liaison-Exécution</em> pour produire un programme. Pour un texte source écrit dans le langage assembleur, l’outil <em>Assembleur</em> détecte toutes les <strong>erreurs de syntaxe</strong> et les signalera au programmeur. Ce dernier devra amender en conséquence son programme et l’assembler à nouveau.</p>

<p>Il est typique que la première version exécutable de votre programme ait quelques <strong>erreurs d’exécution</strong> (<em>anglais</em> : runtime errors). Ces erreurs ne sont pas détectables par l’ outil <em>Assembleur</em>, mais se produisent lorsque vous exécutez votre programme (par exemple, votre programme peut produire des résultats erronés). Par conséquent, vous devez <em>déboguer</em> votre programme pour identifier les erreurs au moment de l’exécution. En ce sense, vous devez exécuter votre programme avec différentes valeurs en entrées et différentes situations de fonctionnement pour vérifier qu’il s’exécute correctement.</p>

<p>Dans <a href="/l2ado/fr/static_files/docs/MARS.html">MARS</a>, vous pouvez utiliser le mode « <em>exécution lente</em> », la fonctionnalité « <em>exécution pas-à-pas</em> », ou encore insérer des « <em>points d’arrêt</em> » dans votre programme pour déboguer les sources d’erreur. L’« <em>exécution pas-à-pas</em> » est une caractéristique standard et essentielle dans tout débogueur. Elle permet d’inspecter l’effet de chaque instruction sur les registres du processeur et la mémoire principale.</p>

<h1 id="registres-et-instructions-du-mips">Registres et instructions du MIPS</h1>

<p>L’architecture MIPS définit 32 registres à usage général, numérotés de <code class="language-plaintext highlighter-rouge">$0</code> à <code class="language-plaintext highlighter-rouge">$31</code>. Le symbole <code class="language-plaintext highlighter-rouge">$</code> est utilisé pour désigner un registre. Pour simplifier le développement de logiciels en assembleur, nous pouvons également se référer aux registres par leurs noms comme indiqué dans le tableau ci-dessous. L’<em>outil Assembleur</em> convertira ensuite les noms des registres en leurs numéros correspondants.</p>

<table class="styled-table">
<colgroup>
<col width="20%" />
<col width="15%" />
<col width="65%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align:center">Numéro</th>
<th style="text-align:center">Nom</th>
<th style="text-align:center">Usage</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">$0</td>
<td style="text-align:center">$0</td>
<td style="text-align:left">Toujours égal à 0</td>
</tr>

<tr>
<td style="text-align:center">$1</td>
<td style="text-align:center">$at</td>
<td style="text-align:left">Est utilisé par l’outil assembleur pour l’expansion des pseudo instructions</td>
</tr>

<tr>
<td style="text-align:center">$2-$3</td>
<td style="text-align:center">$v0-$v1</td>
<td style="text-align:left">Contiennent les valeurs retournées par les fonctions appelées</td>
</tr>

<tr>
<td style="text-align:center">$4-$7</td>
<td style="text-align:center">$a0-$a3</td>
<td style="text-align:left">Utilisés pour passer des arguments aux fonctions appelées</td>
</tr>

<tr>
<td style="text-align:center">$8-$15 , $24-$25</td>
<td style="text-align:center">$t0-$t9</td>
<td style="text-align:left">Utilisés pour manipuler des données temporaires</td>
</tr>

<tr>
<td style="text-align:center">$16-$23</td>
<td style="text-align:center">$s0-$s7</td>
<td style="text-align:left">Utilisés pour manipuler des données locales aux fonctions appelées</td>
</tr>

<tr>
<td style="text-align:center">$26-$27</td>
<td style="text-align:center">$k0-$k1</td>
<td style="text-align:left">Registres Noyaux utilisés par les routines d’exceptions / interruptions</td>
</tr>

<tr>
<td style="text-align:center">$28</td>
<td style="text-align:center">$gp</td>
<td style="text-align:left">Pointeur pour adresser les données globale du programme</td>
</tr>

<tr>
<td style="text-align:center">$29</td>
<td style="text-align:center">$sp</td>
<td style="text-align:left">Pointeur de pile</td>
</tr>

<tr>
<td style="text-align:center">$30</td>
<td style="text-align:center">$fp</td>
<td style="text-align:left">Pointeur de trame</td>
</tr>

<tr>
<td style="text-align:center">$31</td>
<td style="text-align:center">$ra</td>
<td style="text-align:left">Pointeur stockant l’adresse de retour à la fonction appelante</td>
</tr>
</tbody>
</table>

<p>La syntaxe générale d’une instruction dans le langage assembleur MIPS est la suivante :</p>

<pre><code class="language-mips">[label:] mnemonic  [operands]  [#  comment]
</code></pre>

<p><code class="language-plaintext highlighter-rouge">label</code> (ou <strong>étiquette</strong> en français) est facultative. Elle marque l’adresse dans la mémoire de l’instruction et doit être suivie du caractère deux-points (:). En outre, une <strong>étiquette</strong> peut être utilisée pour se référer à l’adresse d’une variable en mémoire.</p>

<p>Le <code class="language-plaintext highlighter-rouge">mnemonic</code> (<strong>mnémonique</strong> en français) indique l’opération à exécuter :  <code class="language-plaintext highlighter-rouge">add</code>, <code class="language-plaintext highlighter-rouge">sub</code>, <code class="language-plaintext highlighter-rouge">sll</code>,  etc.</p>

<p><code class="language-plaintext highlighter-rouge">operands</code> (<strong>opérandes</strong> en français) spécifient les données requises par l’instruction. Différentes instructions ont un nombre différent d’opérandes. Les opérandes peuvent être des registres, des étiquettes ou des constantes. La plupart des instructions arithmétiques et logiques requièrent trois opérandes.</p>

<p>Voici un exemple d’instruction MIPS</p>

<pre><code class="language-mips"> L1: addiu $t0, $t0, 1	# incrémenter $t0
</code></pre>

<p>Un programme écrit en assembleur est constitué d’un ensemble d’instructions de ce genre. En fonction de l’opération réalisée, l’ensemble des instructions MIPS peuvent être regroupées en cinq catégories  :</p>
<ul>
  <li>instructions arithmétiques,</li>
  <li>instructions logiques,</li>
  <li>instructions de transferts,</li>
  <li>instructions de branchement, et</li>
  <li>instructions d’appels système</li>
</ul>

<p><strong>N.B :</strong> Les catégories d’instructions ci-dessous sont décrites dans le format <a href="https://fr.wikipedia.org/wiki/Register_Transfer_Language">RTL</a>. C’est une représentation intermédiaire proche du langage assembleur, mais qui permet une représentation abstraite des instructions. Ici, <code class="language-plaintext highlighter-rouge">rd</code>, <code class="language-plaintext highlighter-rouge">rs</code> et <code class="language-plaintext highlighter-rouge">rt</code> signifient un des 32 registres du MIPS. Par exemple, si <code class="language-plaintext highlighter-rouge">rd = $a0</code>, <code class="language-plaintext highlighter-rouge">rs = $s0</code> et <code class="language-plaintext highlighter-rouge">rt = $0</code> alors la première instruction dans la liste ci-dessous devient en assembleur MIPS :</p>

<pre><code class="language-mips"> add   $a0, $s0, $0	   # $a0 = $s0 + $0
</code></pre>

<h2 id="instructions-arithmétiques">Instructions arithmétiques</h2>

<pre><code class="language-RTL"> add    rd, rs, rt     # rd = rs + rt                      (addition)
 sub    rd, rs, rt     # rd = rs – rt                      (soustraction) 
 addu   rd, rs, rt     # rd = rs + rt                      (addition non signée)  
 subu   rd, rs, rt     # rd = rs - rt                      (soustraction non signée)  
 addi   rt, rs, Imm    # rt = rs + Imm                     (Imm est une constante signée sur 16 bits)
 addiu  rt, rs, Imm    # rt = rs + Imm                     (Imm est une constante signée sur 16 bits)

 mult   rs, rt         # [HI,LO] = rs * rt                 (multiplication) 
 multu  rs, rt         # [HI,LO] = rs * rt                 (multiplication non signée)
 
 div    rs, rt         # HI = rs % rt; LO = rs / rt        (division)
 divu   rs, rt         # HI = rs % rt; LO = rs / rt        (division non signée)  
</code></pre>

<h2 id="instructions-logiques">Instructions logiques</h2>

<pre><code class="language-RTL"> or    rd, rs, rt      # rd = rs | rt                      (OU logique)
 and   rd, rs, rt      # rd = rs &amp; rt                      (ET logique)
 xor   rd, rs, rt      # rd = rs ^ rt                      (OU eXclusif logique) 
 nor   rd, rs, rt      # rd = ~(rs | rt)                   (NON OU logique)
 ori   rt, rs, Imm     # rt = rs | Imm                     (Imm est une constante non-signée sur 16 bits)
 andi  rt, rs, Imm     # rt = rs &amp; Imm                     (Imm est une constante non-signée sur 16 bits)
 xori  rt, rs, Imm     # rt = rs ^ Imm                     (Imm est une constante non-signée sur 16 bits) 

 sllv  rd, rt, rs      # rd = rt &lt;&lt; rs                     (décalage logique à gauche avec rs[4..0])
 srlv  rd, rt, rs      # rd = rt &gt;&gt;&gt; rs                    (décalage logique à droite avec rs[4..0]) 
 srav  rd, rt, rs      # rd = rt &gt;&gt; rs                     (décalage arithmétique avec rs[4..0]) 

 sll   rd, rt, Sha     # rd = rt &lt;&lt; Sha                    (décalage logique à gauche  avec 0 &lt;= Sha &lt;=31)
 srl   rd, rt, Sha     # rd = rt &gt;&gt;&gt; Sha                   (décalage logique à droite  avec 0 &lt;= Sha &lt;=31)
 sra   rd, rt, Sha     # rd = rt &gt;&gt; Sha                    (décalage arithmétique avec 0 &lt;= Sha &lt;= 31)     

 slt   rd, rs, rt      # rd = rs &lt; rt ? 1 : 0              (si rs &lt; rt alors rd = 1 sinon rd = 0)
 sltu  rd, rs, rt      # rd = rs &lt; rt ? 1 : 0              (opérandes non-signés)
 slti  rt, rs, Imm     # rt = rs &lt; Imm ? 1 : 0             (Imm est une constante signée sur 16 bits)
 sltiu rt, rs, Imm     # rt = rs &lt; Imm ? 1 : 0             (Imm est une constante non-signée sur 16 bits)
</code></pre>

<h2 id="instructions-de-transferts-de-données">Instructions de transferts de données</h2>

<pre><code class="language-RTL"> mfhi  rd              # rd = HI                           (lecture du champ HI)
 mflo  rd              # rd = LO                           (lecture du champ LO)
 mthi  rs              # HI = rs                           (initialisation du champ HI)
 mtlo  rs              # LO = rs                           (initialisation du champ LO)
 lui   rt, Imm         # rt = Imm &lt;&lt; 16                    (rt[31..16] = Imm)

 lw    rt, Imm(rs)     # rt = MEM[rs + Imm]                (lecture d'un 'mot' depuis la mémoire)
 sw    rt, Imm(rs)     # MEM[rs + Imm] = rt                (sauvegarde d'un 'mot" dans la mémoire)
 lh    rt, Imm(rs)     # rt = MEM[rs + Imm]                (lecture d'un 'demi-mot' depuis la mémoire)
 lhu   rt, Imm(rs)     # rt = MEM[rs + Imm]                (lecture d'un 'demi-mot' non-signé - sans extension de signe)
 sh    rt, Imm(rs)     # MEM[rs + Imm] = rt                (sauvegarde d'un 'demi-mot' dans la mémoire)
 lb    rt, Imm(rs)     # rt = MEM[rs + Imm]                (lecture d'un 'octet' depuis la mémoire)
 lbu   rt, Imm(rs)     # rt = MEM[rs + Imm]                (lecture d'un 'octet' non-signé - sans extension de signe)
 sb    rt, Imm(rs)     # MEM[rs + Imm] = rt                (sauvegarde d'un 'octet' dans la mémoire)
</code></pre>

<h2 id="instructions-de-branchement-de-code">Instructions de branchement de code</h2>

<pre><code class="language-RTL"> beq   rs, rt, label   # if (rs == rt) goto label          (branchement si égalité)
 bne   rs, rt, label   # if (rs != rt) goto label          (branchement si différent)
 bgez  rs, label       # if (rs &gt;= 0) goto label           (branchement si supérieur ou égal à zéro)
 bgtz  rs, label       # if (rs &gt;  0) goto label           (branchement si supérieur à zéro)
 blez  rs, label       # if (rs &lt;= 0) goto label           (branchement si inférieur ou égal à zéro)
 bltz  rs, label       # if (rs &lt;  0) goto label           (branchement si inférieur à zéro)
 
 j     label           # goto label                        (saut étiquette)
 jal   label           # $ra = $pc + 4 ; goto label        (saut et liaison)
 jr    rs              # $pc = rs                          (saut registre - à l'adresse contenue dans rs)
 jalr  rs              # $ra = $pc + 4 ; $pc = rs          (saut registre et liaison)   
 jalr  rd, rs          # rd  = $pc + 4 ; $pc = rs          (saut registre et liaison dans rd)
</code></pre>

<h2 id="instructions-dappels-système">Instructions d’appels système</h2>

<p>Un programme effectue des entrées et des sorties à l’aide d’instructions spécifiques qui génèrent des appels système. Sur une machine réelle, ces appels sont gérés par le système d’exploitation (Windows, macOS, UN*X, etc) de la machine. Dans l’architecture MIPS, c’est l’instruction spéciale (<code class="language-plaintext highlighter-rouge">syscall</code>) qui permet de générer des « appels système ».</p>

<p>Les routines de gestion des appels système sont spécifiques au système d’exploitation utilisé par la machine. Chaque système d’exploitation fournit son propre ensemble de routines. Sur MARS, qui est un simulateur et non un système réel, il n’y a pas de système d’exploitation impliqué. Le simulateur MARS gère l’exception initiée (nous verrons cela dans un prochain cours) par une instruction <code class="language-plaintext highlighter-rouge">syscall</code> et fournit des services systèmes aux programmes.</p>

<p>Avant d’appeler l’instruction <code class="language-plaintext highlighter-rouge">syscall</code>, le registre <code class="language-plaintext highlighter-rouge">$v0</code> est initialisé avec le numéro de service requis (c-à-d. la fonctionnalité demandée au système d’exploitation) . En outre, les registres <code class="language-plaintext highlighter-rouge">$a0</code>–<code class="language-plaintext highlighter-rouge">$a3</code> sont utilisés pour passer tout argument additionnel à la routine. Après avoir émis l’instruction <code class="language-plaintext highlighter-rouge">syscall</code>, la valeur éventuellement retournée par le système d’exploitation est récupérée depuis le registre <code class="language-plaintext highlighter-rouge">$v0</code>.</p>

<p>Le tableau suivant montre un petit ensemble de services fournis par MARS pour des opérations d’entrée / sortie de base.</p>

<table class="styled-table">
<thead>
<tr class="header">
<th style="text-align:center">Service</th>
<th style="text-align:center">$v0</th>
<th style="text-align:center">Argument(s)</th>
<th style="text-align:center">Retour</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Afficher un entier</td>
<td style="text-align:center">1</td>
<td style="text-align:left"><code class="language-plaintext highlighter-rouge">$a0</code> = entier à afficher</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">Afficher une chaîne de caractères</td>
<td style="text-align:center">4</td>
<td style="text-align:left"><code class="language-plaintext highlighter-rouge">$a0</code> = pointeur sur la chaîne</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">Lire un entier depuis la console</td>
<td style="text-align:center">5</td>
<td style="text-align:left"></td>
<td style="text-align:left"><code class="language-plaintext highlighter-rouge">$v0</code> = entier lu</td>
</tr>
<tr>
<td style="text-align:left">Lire une chaîne de caractères depuis la console</td>
<td style="text-align:center">8</td>
<td style="text-align:left"><code class="language-plaintext highlighter-rouge">$a0</code> = adresse de mémoire où mettre la chaine <br /><code class="language-plaintext highlighter-rouge">$a1</code> = nombre maximum de caractères à lire</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">Terminer l’exécution</td>
<td style="text-align:center">10</td>
<td style="text-align:left"></td>
<td style="text-align:left">Quitte le programme</td>
</tr>
<tr>
<td style="text-align:left">Afficher un caractère</td>
<td style="text-align:center">11</td>
<td style="text-align:left"><code class="language-plaintext highlighter-rouge">$a0</code> = caractère à afficher</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">Lire un caractère</td>
<td style="text-align:center">12</td>
<td style="text-align:left"></td>
<td style="text-align:left"><code class="language-plaintext highlighter-rouge">$v0</code> = caractère lu</td>
</tr>
</tbody>
</table>

<p>L’exemple de code ci-dessous montre un programme simple qui demande à l’utilisateur d’entrer une valeur (un entier), puis affiche cette valeur sur la console de MARS (notre écran simulé).  Cinq appels système sont utilisés. Le premier appel système affiche la chaîne de caractères <code class="language-plaintext highlighter-rouge">str1</code>, le deuxième appel système lit un entier en entrée. Le troisième appel affiche la chaîne de caractères <code class="language-plaintext highlighter-rouge">str2</code>, le quatrième appel système affiche la valeur qui a été entrée par l’utilisateur et le cinquième appel système quitte le programme.</p>

<pre><code class="language-mips">.data
str1:     .asciiz   "Entrez une valeur :"
str2:     .asciiz   "Vous avez entré la valeur :"


.globl main
.text
main:
   addi $v0, $0, 4      # $v0 = n° de service pour 'afficher une chaîne de caractères'
   la   $a0, str1       # $a0 = adresse de la chaîne de caractères str1
   syscall              # appel système pour l'affichage de la chaîne de caractères

   addi $v0, 5          # $v0 = n° de service pour 'lire un entier'
   syscall              # appel système pour la lecture d'un entier. valeur retournée dans $v0

   add  $s0, $v0, $0    # $s0 = $v0  ($s0 = valeur entrée par l'utilisateur)
   addi $v0, $0, 4      # $v0 = n° de service pour 'afficher une chaîne de caractères'
   la   $a0, str2       # $a0 = adresse de la chaîne de caractères str2 
   syscall              # appel système pour l'affichage de la chaîne de caractères

   addi $v0, $0, 1      # $v0 = n° de service pour 'afficher un entier'
   add  $a0, $s0, $0    # $a0 = $s0 ($a0 = valeur à afficher)
   syscall              # appel système pour l'affichage d'un entier.

   addi $v0, $0, 10     # $v0 = n° de service pour 'quitter'
   syscall              # appel système pour quitter le programme
</code></pre>

<h1 id="pseudo-instructions-assembleur">Pseudo-instructions Assembleur</h1>

<p>Les pseudo-instructions sont des « macros » (groupe d’instructions de base) introduites par l’<em>outil Assembleur</em> et se comporte comme s’il s’agissait d’instructions réelles. Les pseudo-instructions sont utiles car elles facilitent la programmation en langage assembleur.
Nous avons vu plus haut un exemple de pseudo-instructions (ex. <code class="language-plaintext highlighter-rouge">bgez</code>-<code class="language-plaintext highlighter-rouge">bltz</code>). Un autre ensemble d’instructions que l’ISA du MIPS n’implémente pas sont les instructions suivantes de branchement conditionnel :</p>

<pre><code class="language-RTL"> blt   rs, rt, label   # if (rs &lt; rt) goto label        (branchement si inférieur)
 bltu  rs, rt, label   # if (rs &lt; rt) goto label        (branchement si inférieur - opérandes non-signés) 
 ble   rs, rt, label   # if (rs &lt;= rt) goto label       (branchement si inférieur ou égal) 
 bleu  rs, rt, label   # if (rs &lt;= rt) goto label       (branchement si inférieur ou égal - opérandes non-signés) 
 bgt   rs, rt, label   # if (rs &gt; rt) goto label        (branchement si supérieur)
 bgtu  rs, rt, label   # if (rs &gt; rt) goto label        (branchement si supérieur - opérandes non-signés) 
 bge   rs, rt, label   # if (rs &gt;= rt) goto label       (branchement si supérieur ou égal) 
 bgeu  rs, rt, label   # if (rs &gt;= rt) goto label       (branchement si supérieur ou égal - opérandes non-signés) 
</code></pre>

<p>Ces instructions ne sont pas implémentées dans l’ISA du MIPS parce qu’elles peuvent être facilement mises en œuvre en utilisant un ensemble réduit d’instructions réelles. Par exemple, la pseudo-instruction <code class="language-plaintext highlighter-rouge">blt $s0, $s1, etiq</code> peut être remplacée par la séquence suivante d’instructions réelles :</p>

<pre><code class="language-mips"> slt  $at, $a0, $s1
 bne  $at, $0, etiq
</code></pre>

<p>De manière similaire, la pseudo-instruction <code class="language-plaintext highlighter-rouge">ble $s2, $s3, etiq</code> sera convertie par l’<em>outil Assembleur</em> en cette séquence d’instructions réelles :</p>

<pre><code class="language-mips"> slt  $at, $s3, $s2
 beq  $at, $0, etiq
</code></pre>

<p>Notez l’utilisation du registre <code class="language-plaintext highlighter-rouge">$at</code> comme registre temporaire lors de la conversion des pseudo-instructions en instructions réelles. <strong>Ce registre est réservé par l’<em>outil Assembleur</em> à cet usage</strong>.  Le tableau ci-dessous illustre d’autres exemples de pseudo-instructions MIPS.</p>

<table class="styled-table">
<thead>
<tr class="header">
<th style="text-align:center">Pseudo-instruction</th>
<th style="text-align:center">Instruction(s) réelle(s)</th>
<th style="text-align:center">Opération</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><samp>move $s1, $s2</samp></td>
<td style="text-align:left"><samp>addu $s1, $2, $0</samp></td>
<td style="text-align:left"><samp>$s1 = $s2</samp></td>
</tr>
<tr>
<td style="text-align:left"><samp>not $s1, $s2</samp></td>
<td style="text-align:left"><samp>nor $s1, $s2, $0</samp></td>
<td style="text-align:left"><samp>$s1 = not($s2)</samp></td>
</tr>
<tr>
<td style="text-align:left"><samp>li $s1, 0xabcd</samp></td>
<td style="text-align:left"><samp>ori $s1, $0, 0xabcd</samp></td>
<td style="text-align:left"><samp>$s1 = 0x0000abcd</samp></td>
</tr>
<tr>
<td style="text-align:left; vertical-align:top"><samp>li $s1, 0xabcd1234</samp></td>
<td style="text-align:left"><samp>lui $at, $x0abcd</samp><br /><samp>ori $s1, $at, 0x1234</samp></td>
<td style="text-align:left; vertical-align:top"><samp>$s1 = 0xabcd1234</samp></td>
</tr>
<tr>
<td style="text-align:left"><samp>sgt $s1, $s2, $s3</samp></td>
<td style="text-align:left"><samp>slt $s1, $s3, $s2</samp></td>
<td style="text-align:left"><samp>$s1 = $s2 &gt; $s3 ? 1 : 0</samp></td>
</tr>
<tr>
<td style="text-align:left; vertical-align:top"><samp>blt $s1, $s2, label</samp></td>
<td style="text-align:left"><samp>slt $at, $s1, $s2<br /><samp>bne $at, $0, label</samp></samp></td>
<td style="text-align:left; vertical-align:top"><samp>if $s1 &lt; $s2 goto label</samp></td>
</tr>
</tbody>
</table>

<h1 id="traduction-vers-le-mips-des-structures-de-contrôle-dans-les-langages-évolués">Traduction vers le MIPS des structures de contrôle dans les langages évolués</h1>

<p>Nous pouvons traduire vers l’assembleur n’importe quelle structure de contrôle de haut niveau à l’aide d’instructions de branchement. Considérons le test <code class="language-plaintext highlighter-rouge">if</code> suivant dans le langage C :</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">if</span> <span class="p">(</span> <span class="n">a</span> <span class="o">==</span> <span class="n">b</span> <span class="p">)</span>
     <span class="n">c</span> <span class="o">=</span> <span class="n">d</span> <span class="o">+</span> <span class="n">e</span><span class="p">;</span>
  <span class="k">else</span>
     <span class="n">c</span> <span class="o">=</span> <span class="n">d</span> <span class="o">-</span> <span class="n">e</span><span class="p">;</span>
</code></pre></div></div>

<p>Supposons que le compilateur C ait associé les registres <code class="language-plaintext highlighter-rouge">$s0</code> - <code class="language-plaintext highlighter-rouge">$s4</code> au variables <code class="language-plaintext highlighter-rouge">a</code>,<code class="language-plaintext highlighter-rouge">b</code>,<code class="language-plaintext highlighter-rouge">c</code>,<code class="language-plaintext highlighter-rouge">d</code> et <code class="language-plaintext highlighter-rouge">e</code>. Le test ci-dessus peut être effectué en assembleur MIPS avec les instructions suivantes :</p>

<pre><code class="language-mips">  bne  $s0, $s1, ELSE
  add  $s2, $s3, $s4 
  j EXIT
ELSE:	
  sub  $s2, $s3, $s4 
EXIT: 
  . . .
</code></pre>

<p>Nous pouvons aussi implémenter une condition composée impliquant l’opérateur logique <code class="language-plaintext highlighter-rouge">&amp;&amp;</code> :</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">if</span> <span class="p">(</span> <span class="p">(</span><span class="n">b</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">c</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">)</span>
     <span class="n">d</span><span class="o">++</span><span class="p">;</span>
</code></pre></div></div>

<p>En assembleur, l’instruction <code class="language-plaintext highlighter-rouge">if</code> ci-dessus est implémentée en utilisant le concept de chute (<em>anglais</em> : fall through) en algorithmique. L’idée ici est de ‘sauter’ l’exécution de l’instruction suivant le test si la condition n’est pas vérifiée :</p>

<pre><code class="language-mips">  blez   $s1, next    # sauter si b &lt;= 0
  bgez   $s2, next    # sauter si c &gt;= 0
  addiu  $s3, $s3, 1  # d++ ; les deux conditions sont vraies
next: 
  . . .
</code></pre>

<p>De façon similaire, nous pouvons aussi traduire un test <code class="language-plaintext highlighter-rouge">if</code> avec une condition composée impliquant l’opérateur logique <code class="language-plaintext highlighter-rouge">||</code>. Par exemple :</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="k">if</span> <span class="p">(</span> <span class="p">(</span><span class="n">b</span> <span class="o">&gt;</span> <span class="n">c</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">c</span> <span class="o">&gt;</span> <span class="n">d</span><span class="p">)</span> <span class="p">)</span> 
   <span class="n">e</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</code></pre></div></div>

<p>L’implémentation en assembleur ci dessous vérifie la première condition du test si elle est vraie et saute en conséquence la vérification de la deuxième condition :</p>

<pre><code class="language-mips">  bgt    $s1, $s2, L1    # sauter au corps du if si b &gt; c
  ble    $s2, $s3, next  # sauter à l'extérieur du if si c &lt;= d   (b &lt;= c implicitement)
L1:  
  addi   $s4, $s0, 1     # e = 1
next: 
  . . .
</code></pre>

<h1 id="un-pas-à-pas-du-c-au-mips">Un pas-à-pas du C au MIPS</h1>

<p>Afin de mieux comprendre les idées et les règles discutées ci-dessus, nous allons parcourir la traduction d’un programme C en programme MIPS. Le code suivant en langage C imprime le nième nombre de Fibonacci.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">9</span><span class="p">;</span>

<span class="c1">// Function to find the nth Fibonacci number</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">curr_fib</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">next_fib</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">new_fib</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">new_fib</span> <span class="o">=</span> <span class="n">curr_fib</span> <span class="o">+</span> <span class="n">next_fib</span><span class="p">;</span>
        <span class="n">curr_fib</span> <span class="o">=</span> <span class="n">next_fib</span><span class="p">;</span>
        <span class="n">next_fib</span> <span class="o">=</span> <span class="n">new_fib</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">curr_fib</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Voyons comment nous allons traduire cela étape par étape. Tout d’abord, nous devons réécrire le code source c dans une <a href="/l2ado/fr/static_files/docs/non_structured_programming.html">version non structurée</a>.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">9</span><span class="p">;</span>

<span class="c1">// Function to find the nth Fibonacci number</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">curr_fib</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">next_fib</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">new_fib</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>

<span class="nl">WHILE:</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">goto</span> <span class="n">ELIHW</span><span class="o">:</span>
    <span class="n">new_fib</span>  <span class="o">=</span> <span class="n">curr_fib</span> <span class="o">+</span> <span class="n">next_fib</span><span class="p">;</span>
    <span class="n">curr_fib</span> <span class="o">=</span> <span class="n">next_fib</span><span class="p">;</span>
    <span class="n">next_fib</span> <span class="o">=</span> <span class="n">new_fib</span><span class="p">;</span>
    <span class="n">i</span><span class="o">--</span><span class="p">;</span>
    <span class="k">goto</span> <span class="n">WHILE</span><span class="p">;</span>

<span class="nl">ELIHW:</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">curr_fib</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Ensuite, nous devons définir la variable globale <code class="language-plaintext highlighter-rouge">n</code>. Dans MIPS, les variables globales sont déclarées sous la directive <code class="language-plaintext highlighter-rouge">.data</code> qui représente le segment de données. la déclaration sous MIPS ressemble à ceci :</p>

<pre><code class="language-mips">.data
n: .word 9
</code></pre>

<ul>
  <li>L’étiquette <code class="language-plaintext highlighter-rouge">n</code> est le nom de la variable,,</li>
  <li><code class="language-plaintext highlighter-rouge">.word</code> signifie que la donnée est de type ‘mot’,</li>
  <li><code class="language-plaintext highlighter-rouge">9</code> est la valeur attribuée à <code class="language-plaintext highlighter-rouge">n</code>.</li>
</ul>

<p>Passons à l’initialisation de <code class="language-plaintext highlighter-rouge">curr_fib</code> et <code class="language-plaintext highlighter-rouge">next_fib</code>. Comme il s’agit de variables locales dans notre code c, elles seront affectées à certains registres du processeur MIPS. Par convention, les registres <code class="language-plaintext highlighter-rouge">$s0</code>-<code class="language-plaintext highlighter-rouge">$s7</code> sont utilisés pour les variables locales dans MIPS.</p>

<pre><code class="language-mips">.text
main:
    add  $s0, $0, $0    # curr_fib = 0
    addi $s1, $0,  1    # next_fib = 1
</code></pre>

<ul>
  <li>Nous avons ajouté ici la directive <code class="language-plaintext highlighter-rouge">.text</code>. Toute instruction sous cette directive appartient à notre <em>code exécutable</em>.</li>
  <li>Rappelons que le registre $0 est immuable. Il contient toujours la valeur 0.</li>
  <li>La variable locale <code class="language-plaintext highlighter-rouge">new_fib</code> n’est pas déclarée (nous ne déclarons pas de variables dans MIPS, mais nous leurs associons des registres).</li>
</ul>

<p>Passons maintenant à la boucle et commençons par initialiser sa variable d’itération. Le code suivant affecte à <code class="language-plaintext highlighter-rouge">i</code> la valeur de <code class="language-plaintext highlighter-rouge">n</code>.</p>

<pre><code class="language-mips">    la $t0, n           # récupérer dans t0 l'adresse de l'étiquette n
    lw $t0, 0($t0)      # récupérer la valeur stockée à l'adresse pointée par l'étiquette n
</code></pre>

<p>En langage C, les instructions MIPS ci-dessus ressemblent à ceci</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="n">t0</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">;</span>
 <span class="n">t0</span> <span class="o">=</span> <span class="o">*</span><span class="n">t0</span><span class="p">;</span>
</code></pre></div></div>

<p>L’instruction <code class="language-plaintext highlighter-rouge">la</code> charge l’adresse d’une étiquette dans un registre donné. La première ligne définit essentiellement <code class="language-plaintext highlighter-rouge">$t0</code> comme étant un pointeur vers <code class="language-plaintext highlighter-rouge">n</code>. la deuxième ligne utilise <code class="language-plaintext highlighter-rouge">lw</code> pour déréférencer <code class="language-plaintext highlighter-rouge">$t0</code> et fixe ce registre à la valeur stockée dans <code class="language-plaintext highlighter-rouge">n</code>.</p>

<p>Vous pensez probablement : « Pourquoi ne pouvons-nous pas définir directement <code class="language-plaintext highlighter-rouge">$t0</code> sur <code class="language-plaintext highlighter-rouge">n</code> ? » Dans la section <code class="language-plaintext highlighter-rouge">.text</code> du code, il n’y a aucun moyen d’accéder directement à <code class="language-plaintext highlighter-rouge">n</code> qui est dans la section <code class="language-plaintext highlighter-rouge">.data</code> (Nous ne pouvons pas écrire <code class="language-plaintext highlighter-rouge">add $t0, n, $0</code> car les arguments de l’instruction <code class="language-plaintext highlighter-rouge">add</code> <strong>doivent être des registres</strong> et <code class="language-plaintext highlighter-rouge">n</code> <strong>n’est pas</strong> un registre). La seule façon d’accéder à <code class="language-plaintext highlighter-rouge">n</code> est d’obtenir son adresse avec l’instruction <code class="language-plaintext highlighter-rouge">la</code>. Une fois l’adresse de <code class="language-plaintext highlighter-rouge">n</code> connue, nous pouvons accéder au contenu de la variable avec <code class="language-plaintext highlighter-rouge">lw</code>. L’instruction <code class="language-plaintext highlighter-rouge">lw</code> permet d’affecter au registre <code class="language-plaintext highlighter-rouge">rt</code> (<code class="language-plaintext highlighter-rouge">$t0</code> pour cet exemple) la donnée stockée en mémoire <code class="language-plaintext highlighter-rouge">MEM[Imm + rs]</code> (<code class="language-plaintext highlighter-rouge">MEM[0 + $t0]</code> pour cet exemple).</p>

<p>Passons au corps de la boucle maintenant et commençons par créer la structure externe de celle-ci :</p>

<pre><code class="language-mips">WHILE:
    beq $t0, $0, ELIHW  # sortir de la boucle une fois que nous avons effectué n itérations
    ...
    ...
    addi $t0, $t0, -1   # décrémenter le compteur de la boucle
    j WHILE             # boucler (sauter à l'étiquette WHILE)
ELIHW:
</code></pre>

<ul>
  <li>
    <p>La première ligne (<code class="language-plaintext highlighter-rouge">WHILE:</code>) est une étiquette que nous utilisons pour revenir au début de la boucle.</p>
  </li>
  <li>
    <p>La ligne suivante (<code class="language-plaintext highlighter-rouge">beq $t0, $0, ELIHW</code>) définie notre condition de sortie. Ici, nous branchons sur une autre étiquette, <code class="language-plaintext highlighter-rouge">ELIHW</code>, une fois que <code class="language-plaintext highlighter-rouge">$t0</code> (qui représente la variable <code class="language-plaintext highlighter-rouge">i</code>) atteigne la valeur <code class="language-plaintext highlighter-rouge">0</code>.</p>
  </li>
  <li>
    <p>À la fin du corps de la boucle, la ligne (<code class="language-plaintext highlighter-rouge">addi $t0, $t0, -1</code>) décrémente la variable <code class="language-plaintext highlighter-rouge">i</code>.</p>
  </li>
  <li>
    <p>L’instruction suivante (<code class="language-plaintext highlighter-rouge">j WHILE</code>) revient au début de la boucle.</p>
  </li>
</ul>

<p>Maintenant, ajoutons la structure interne de la boucle.</p>

<pre><code class="language-mips">WHILE:
    beq $t0, $0, ELIHW  # sortir de la boucle une fois que nous avons effectué n itérations
     
    add $t2, $s0, $s1   # new_fib  = curr_fib + next_fib;
    add $s0, $s1, $0    # curr_fib = next_fib;
    add $s1, $t2, $0    # next_fib = new_fib;
     
    addi $t0, $t0, -1   # décrémenter le compteur de la boucle
    j WHILE             # boucler (sauter à l'étiquette WHILE)
ELIHW:
</code></pre>

<p>Rien de spécial ici, les lignes C correspondantes sont indiquées dans les commentaires. Passons maintenant à l’affichage du nième nombre de Fibonacci !</p>

<pre><code class="language-mips">ELIHW:
    addi $v0,  $0, 1    # $v0 = n° de service pour 'afficher un entier' 
    addi $a0, $s0, 0    # $a0 = la valeur à afficher 
    syscall             # appel système pour l'affichage d'un entier
</code></pre>

<p>L’affichage de données est un appel système. Vous en apprendrez plus à ce sujet plus tard dans le semestre, mais un appel système est essentiellement un moyen pour votre programme d’interagir avec le système d’exploitation. Pour effectuer un appel système dans MIPS, nous utilisons une instruction spéciale appelée <code class="language-plaintext highlighter-rouge">syscall</code>. Pour afficher un entier, nous devons passer deux arguments à <code class="language-plaintext highlighter-rouge">syscall</code>. Le premier argument spécifie ce que nous voulons que <code class="language-plaintext highlighter-rouge">syscall</code> fasse (dans ce cas, affiche un entier). Pour spécifier que nous voulons imprimer un entier, nous définissons <code class="language-plaintext highlighter-rouge">$v0</code> sur <code class="language-plaintext highlighter-rouge">1</code>. L’entier que nous voulons afficher est passé en argument via <code class="language-plaintext highlighter-rouge">a0</code>.</p>

<p>En C, nous sommes habitués aux fonctions ressemblant à <code class="language-plaintext highlighter-rouge">afficher(s0)</code>. Dans MIPS, nous ne pouvons pas passer d’arguments de cette manière. Pour passer un argument à une fonction, nous devons le placer dans un registre d’arguments (<code class="language-plaintext highlighter-rouge">$a0</code>-<code class="language-plaintext highlighter-rouge">$a3</code>). Lorsque la fonction est appelée, elle récupère depuis ces registres tout éventuel argument. Le premier argument doit être placé dans <code class="language-plaintext highlighter-rouge">$a0</code>, le second dans <code class="language-plaintext highlighter-rouge">$a1</code>, etc. Consultez <a href="/l2ado/fr/static_files/docs/MIPS_Calling_Convention.html">ce lien</a> pour plus de détails sur l’appel des fonctions dans MIPS et le passage des arguments.</p>

<p>Enfin, terminons notre programme ! Cela nécessite également un <code class="language-plaintext highlighter-rouge">syscall</code> !</p>

<pre><code class="language-mips">    addi $v0, $0, 10    # n° de service pour 'quitter'
    syscall             # appel système pour quitter le programme
</code></pre>

<p>Et voila! Voici notre programme complet !</p>

<pre><code class="language-mips">.data
n: .word 9

.text
main:
    add  $s0, $0, $0    # curr_fib = 0
    addi $s1, $0,  1    # next_fib = 1

    la $t0, n           # récupérer dans t0 l'adresse de l'étiquette n
    lw $t0, 0($t0)      # récupérer la valeur stockée à l'adresse pointée par l'étiquette n

WHILE:
    beq $t0, $0, ELIHW  # sortir de la boucle une fois que nous avons effectué n itérations
     
    add $t2, $s0, $s1   # new_fib  = curr_fib + next_fib;
    add $s0, $s1, $0    # curr_fib = next_fib;
    add $s1, $t2, $0    # next_fib = new_fib;
     
    addi $t0, $t0, -1   # décrémenter le compteur de la boucle
    j WHILE             # boucler (sauter à l'étiquette WHILE)

ELIHW:
    addi $v0,  $0, 1    # $v0 = n° de service pour 'afficher un entier' 
    addi $a0, $s0, 0    # $a0 = la valeur à afficher 
    syscall             # appel système pour l'affichage d'un entier

    addi $v0, $0, 10    # n° de service pour 'quitter'
    syscall             # appel système pour quitter le programme
</code></pre>


  </article>

</div>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <!--     <h2 class="footer-heading"></h2> -->
    <div class="footer-col-wrapper">
      <div class="footer-col  footer-col-1">

        <p class="text">
          02 rue Didouche Mourad<br />
16000 Alger<br />
 
        </p>
      </div>

      <div class="footer-col  footer-col-2">
        <ul class="social-media-list">


          

          

          

          

          
          




        </ul>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
